diff --git a/pip/__init__.py b/pip/__init__.py
index 3d4b45a..3aa11e8 100644
--- a/pip/__init__.py
+++ b/pip/__init__.py
@@ -11,3 +11,6 @@ def main(args: Optional[List[str]] = None) -> int:
     from pip._internal.utils.entrypoints import _wrapper
 
     return _wrapper(args)
+
+
+__GRAALPY_PATCHED = True
diff --git a/pip/_internal/cli/cmdoptions.py b/pip/_internal/cli/cmdoptions.py
index 47ed927..1d182de 100644
--- a/pip/_internal/cli/cmdoptions.py
+++ b/pip/_internal/cli/cmdoptions.py
@@ -891,7 +891,7 @@ disable_pip_version_check: Callable[..., Option] = partial(
     "--disable-pip-version-check",
     dest="disable_pip_version_check",
     action="store_true",
-    default=False,
+    default=True, # GraalPy: we do not want to incentivize the upgrade
     help="Don't periodically check PyPI to determine whether a new version "
     "of pip is available for download. Implied with --no-index.",
 )
diff --git a/pip/_internal/index/package_finder.py b/pip/_internal/index/package_finder.py
index 9bf247f..8167348 100644
--- a/pip/_internal/index/package_finder.py
+++ b/pip/_internal/index/package_finder.py
@@ -38,6 +38,7 @@ from pip._internal.utils.logging import indent_log
 from pip._internal.utils.misc import build_netloc
 from pip._internal.utils.packaging import check_requires_python
 from pip._internal.utils.unpacking import SUPPORTED_EXTENSIONS
+from pip._internal.utils.graalpy import apply_graalpy_sort_order
 
 __all__ = ["FormatControl", "BestCandidateResult", "PackageFinder"]
 
@@ -487,6 +488,7 @@ class CandidateEvaluator:
 
         return sorted(filtered_applicable_candidates, key=self._sort_key)
 
+    @apply_graalpy_sort_order
     def _sort_key(self, candidate: InstallationCandidate) -> CandidateSortingKey:
         """
         Function to pass as the `key` argument to a call to sorted() to sort
diff --git a/pip/_internal/operations/install/wheel.py b/pip/_internal/operations/install/wheel.py
index 1af8978..15fee7f 100644
--- a/pip/_internal/operations/install/wheel.py
+++ b/pip/_internal/operations/install/wheel.py
@@ -587,6 +587,9 @@ def _install_wheel(
         file.save()
         record_installed(file.src_record_path, file.dest_path, file.changed)
 
+    from pip._internal.utils.graalpy import apply_graalpy_patches
+    apply_graalpy_patches(wheel_path, lib_dir)
+
     def pyc_source_file_paths() -> Generator[str, None, None]:
         # We de-duplicate installation paths, since there can be overlap (e.g.
         # file in .data maps to same location as file in wheel root).
diff --git a/pip/_internal/utils/graalpy.py b/pip/_internal/utils/graalpy.py
new file mode 100644
index 0000000..a54f11a
--- /dev/null
+++ b/pip/_internal/utils/graalpy.py
@@ -0,0 +1,189 @@
+# ATTENTION: GraalPy uses existence of this module to verify that it is
+# running a patched pip in pip_hook.py
+import os
+import re
+from pathlib import Path
+
+from pip._vendor import tomli
+from pip._vendor.packaging.specifiers import Specifier
+from pip._vendor.packaging.version import VERSION_PATTERN
+
+PATCHES_BASE_DIRS = [os.path.join(__graalpython__.core_home, "patches")]
+if hasattr(__graalpython__, "tdebug"):
+    PATCHES_BASE_DIRS += os.environ.get('PIPLOADER_PATCHES_BASE_DIRS', "").split(",")
+
+BUNDLED_WHEELS_PATH = None
+
+
+def is_bundled_wheel(location, package_name):
+    return os.path.exists(os.path.join(location, package_name, '.graalpy_bundled'))
+
+
+def normalize_name(name):
+    return re.sub('[-_.]+', '-', name).lower()
+
+
+class PatchRepository:
+    def __init__(self, base_dirs):
+        self._repository = {}
+        for base_dir in base_dirs:
+            for package_dir in Path(base_dir).iterdir():
+                denormalized_name = package_dir.name
+                normalized_name = normalize_name(denormalized_name)
+                metadata = {}
+                if (metadata_path := package_dir / 'metadata.toml').is_file():
+                    with open(metadata_path, 'rb') as f:
+                        metadata = tomli.load(f)
+                    metadata.setdefault('patches', [])
+                    for patch_rule in metadata['patches']:
+                        patch_rule['patch'] = package_dir / patch_rule['patch']
+                    metadata['prefer-versions'] = frozenset(metadata.get('prefer-versions', []))
+                else:
+                    # TODO legacy structure, simplify when we get rid of ginstall
+                    metadata['patches'] = []
+                    for dist_type in ('whl', 'sdist'):
+                        typedir = package_dir / dist_type
+                        if typedir.is_dir():
+                            files = sorted(typedir.iterdir(), key=lambda f: len(f.name), reverse=True)
+                            for file in files:
+                                if file.suffix == '.patch':
+                                    if file.stem == denormalized_name:
+                                        metadata['patches'].append({
+                                            'patch': str(file),
+                                            'type': dist_type,
+                                        })
+                                    elif (version := file.stem.removeprefix(f'{denormalized_name}-')) != file.stem:
+                                        metadata['patches'].append({
+                                            'version': f'== {version}',
+                                            'patch': file,
+                                            'type': dist_type,
+                                        })
+                            for file in files:
+                                if file.suffix == '.dir':
+                                    with open(file) as f:
+                                        subdir = f.read().strip()
+                                    for patch_rule in metadata['patches']:
+                                        patch_rule['subdir'] = subdir
+                        metadata['prefer-versions'] = {rule.get('version') for rule in metadata['patches']}
+                        if None in metadata['prefer-versions']:
+                            metadata['prefer-versions'] = None
+                self._repository[normalized_name] = metadata
+
+    def _deep_get(self, *args):
+        res = self._repository
+        for arg in args:
+            res = res.get(arg)
+            if not res:
+                return None
+        return res
+
+    def _get_metadata(self, name):
+        return self._repository.get(normalize_name(name))
+
+    def get_preferred_version_specs(self, name):
+        if metadata := self._get_metadata(name):
+            return metadata['prefer-versions']
+
+    def get_patch_version_specs(self, name):
+        versions = set()
+        if metadata := self._get_metadata(name):
+            for patch_rule in metadata['patches']:
+                if version := patch_rule.get('version'):
+                    versions.add(version)
+        return versions
+
+    def get_patch_rule(self, name, requested_version, dist_type):
+        if metadata := self._get_metadata(name):
+            for patch_rule in metadata['patches']:
+                if patch_rule.get('dist-type', dist_type) != dist_type:
+                    continue
+                if patch_rule.get('version') and not Specifier(patch_rule['version']).contains(requested_version):
+                    continue
+                return patch_rule
+            else:
+                return None
+
+
+__PATCH_REPOSITORY = None
+
+
+def get_patch_repository():
+    global __PATCH_REPOSITORY
+    if not __PATCH_REPOSITORY:
+        __PATCH_REPOSITORY = PatchRepository(PATCHES_BASE_DIRS)
+    return __PATCH_REPOSITORY
+
+
+def apply_graalpy_patches(filename, location):
+    """
+    Applies any GraalPy patches to package extracted from 'filename' into 'location'.
+    Note that 'location' must be the parent directory of the package directory itself.
+    For example: /path/to/site-package and not /path/to/site-packages/mypackage.
+    """
+    import autopatch_capi
+    import subprocess
+
+    autopatch_capi.auto_patch_tree(location)
+
+    # we expect filename to be something like "pytest-5.4.2-py3-none-any.whl"
+    archive_name = os.path.basename(filename)
+    name_ver_match = re.match(fr"^(?P<name>.*?)-(?P<version>{VERSION_PATTERN}).*?\.(?P<suffix>tar\.gz|tar|whl|zip)$",
+                              archive_name, re.VERBOSE | re.I)
+    if not name_ver_match:
+        print(f"GraalPy warning: could not parse package name, version, or format from {archive_name!r}.\n"
+              "Could not determine if any GraalPy specific patches need to be applied.")
+        return
+
+    name = name_ver_match.group('name')
+    version_spec = name_ver_match.group('version')
+    suffix = name_ver_match.group('suffix')
+    is_wheel = suffix == "whl"
+
+    # Avoid applying patches to bundled wheels, they are already patched
+    if is_wheel and is_bundled_wheel(location, name):
+        return
+
+    print(f"Looking for GraalPy patches for {name}")
+    repository = get_patch_repository()
+
+    if is_wheel:
+        # patches intended for binary distribution:
+        patch_rule = repository.get_patch_rule(name, version_spec, 'wheel')
+    else:
+        # patches intended for source distribution if applicable
+        patch_rule = repository.get_patch_rule(name, version_spec, 'sdist')
+        if not patch_rule:
+            patch_rule = repository.get_patch_rule(name, version_spec, 'wheel')
+        if patch_rule and (subdir := patch_rule.get('subdir')):
+            # we may need to change wd if we are actually patching a source distribution
+            # with a patch intended for a binary distribution, because in the source
+            # distribution the actual deployed sources may be in a subdirectory (typically "src")
+            location = os.path.join(location, subdir)
+    if patch_rule:
+        print(f"Patching package {name} using {patch_rule['patch']}")
+        try:
+            subprocess.run(["patch", "-f", "-d", location, "-p1", "-i", str(patch_rule['patch'])], check=True)
+        except FileNotFoundError:
+            print(
+                "WARNING: GraalPy needs the 'patch' utility to apply compatibility patches. Please install it using your system's package manager.")
+        except subprocess.CalledProcessError:
+            print(f"Applying GraalPy patch failed for {name}. The package may still work.")
+    elif version_specs := repository.get_patch_version_specs(name):
+        print("We have patches to make this package work on GraalVM for some version(s).")
+        print("If installing or running fails, consider using one of the versions that we have patches for:")
+        for version_spec in version_specs:
+            print(f'{name} {version_spec}')
+
+
+def apply_graalpy_sort_order(sort_key_func):
+    def wrapper(self, candidate):
+        default_sort_key = sort_key_func(self, candidate)
+        name = candidate.name
+        version = str(candidate.version)
+        if preferred_versions := get_patch_repository().get_preferred_version_specs(name):
+            for preferred_version in preferred_versions:
+                if Specifier(preferred_version).contains(version):
+                    return 1, default_sort_key
+        return 0, default_sort_key
+
+    return wrapper
diff --git a/pip/_internal/utils/unpacking.py b/pip/_internal/utils/unpacking.py
index 78b5c13..18a184c 100644
--- a/pip/_internal/utils/unpacking.py
+++ b/pip/_internal/utils/unpacking.py
@@ -255,3 +255,5 @@ def unpack_file(
             content_type,
         )
         raise InstallationError(f"Cannot determine archive format of {location}")
+    from pip._internal.utils.graalpy import apply_graalpy_patches
+    apply_graalpy_patches(filename, location)
