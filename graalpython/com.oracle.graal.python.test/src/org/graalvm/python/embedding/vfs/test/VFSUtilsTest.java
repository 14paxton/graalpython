/*
 * Copyright (c) 2025, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * The Universal Permissive License (UPL), Version 1.0
 *
 * Subject to the condition set forth below, permission is hereby granted to any
 * person obtaining a copy of this software, associated documentation and/or
 * data (collectively the "Software"), free of charge and under any and all
 * copyright rights in the Software, and any and all patent rights owned or
 * freely licensable by each licensor hereunder covering either (i) the
 * unmodified Software as contributed to or provided by such licensor, or (ii)
 * the Larger Works (as defined below), to deal in both
 *
 * (a) the Software, and
 *
 * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if
 * one is included with the Software each a "Larger Work" to which the Software
 * is contributed by such licensors),
 *
 * without restriction, including without limitation the rights to copy, create
 * derivative works of, display, perform, and distribute the Software and make,
 * use, sell, offer for sale, import, export, have made, and have sold the
 * Software and the Larger Work(s), and to sublicense the foregoing rights on
 * either these or other terms.
 *
 * This license is subject to the following condition:
 *
 * The above copyright notice and either this complete permission notice or at a
 * minimum a reference to the UPL must be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package org.graalvm.python.embedding.vfs.test;

import org.graalvm.python.embedding.test.EmbeddingTestUtils;
import org.graalvm.python.embedding.tools.exec.BuildToolLog;
import org.graalvm.python.embedding.tools.vfs.VFSUtils;
import org.junit.Test;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import static org.graalvm.python.embedding.test.EmbeddingTestUtils.createLauncher;
import static org.graalvm.python.embedding.test.EmbeddingTestUtils.delete;
import static org.graalvm.python.embedding.test.EmbeddingTestUtils.deleteDirOnShutdown;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

public class VFSUtilsTest {

    private static final String REQUIREMENTS_HEADER = "generated by graalpy tests\nwith a two line header";
    private static final String INCONSISTENT_PKGS_ERROR = "requirements %s inconsistent with packages %s";
    private static final String WRONG_PKG_VERSION_ERROR = "wrong package version %s";
    private static final String MISSING_REQUIREMENTS_FILE_WARNING = "missing requirements file";

    private static final class TestLog implements BuildToolLog {
        private final StringBuilder output = new StringBuilder();

        private void addLine(String s) {
            this.output.append('\n').append(s);
        }

        private void clearOutput() {
            output.delete(0, output.length());
        }

        public void subProcessOut(String s) {
            println("[subout] ", s);
            addLine(s.toString());
        }

        public void subProcessErr(String s) {
            println("[suberr] ", s);
            addLine(s.toString());
        }

        public void info(String s) {
            println("[info] ", s);
            addLine(s);
        }

        public void warning(String s) {
            println("[warn] ", s);
            addLine(s);
        }

        public void warning(String s, Throwable t) {
            println("[warn] ", s);
            t.printStackTrace();
            addLine(s);
        }

        public void error(String s) {
            println("[err] ", s);
            addLine(s);
        }

        @Override
        public void debug(String s) {
            println("[debug] ", s);
            addLine(s);
        }

        @Override
        public boolean isWarningEnabled() {
            return true;
        }

        @Override
        public boolean isInfoEnabled() {
            return true;
        }

        @Override
        public boolean isErrorEnabled() {
            return true;
        }

        @Override
        public boolean isSubprocessOutEnabled() {
            return true;
        }

        @Override
        public boolean isDebugEnabled() {
            return isVerbose();
        }

        public String getOutput() {
            return output.toString();
        }

        static void println(String... args) {
            if (isVerbose()) {
                System.out.println(String.join(" ", args));
            }
        }

        private static boolean isVerbose() {
            return Boolean.getBoolean("com.oracle.graal.python.test.verbose");
        }
    }

    /**
     * tests scenarios when packages are declared only in plugin config
     */
    @Test
    public void testWithPackagesOnlyFromPluginConfig() throws IOException {
        TestLog log = new TestLog();
        Path tmpDir = Files.createTempDirectory("VFSUtilsTest_testWithPackagesOnlyFromPluginConfig");
        Path venvDir = tmpDir.resolve("venv");
        deleteDirOnShutdown(tmpDir);

        // test with a not existing requirements path
        // the maven and gradle plugins always send the default requirements path, no matter if the
        // file exists or not
        Path requirements = tmpDir.resolve("requirements.txt");
        Path contents = venvDir.resolve("contents");

        // no packages, requirements file does not exist - does nothing
        log.clearOutput();
        createVenv(venvDir, "0.1", log, requirements);
        assertFalse(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), false);
        assertFalse(log.getOutput().contains("pip install"));

        // install packages
        log.clearOutput();
        createVenv(venvDir, "0.1", log, requirements, "hello-world", "tiny-tiny");
        assertTrue(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), true);
        assertTrue(log.getOutput().contains("pip install"));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world", "tiny-tiny");
        checkVenvContentsFile(contents, "0.1", "hello-world", "tiny-tiny");

        // install packages again, assert that venv wasn't created and packages weren't installed
        log.clearOutput();
        createVenv(venvDir, "0.1", log, requirements, "hello-world", "tiny-tiny");
        assertTrue(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), false);
        assertFalse(log.getOutput().contains("pip install"));
        assertFalse(log.getOutput().contains("hello-world"));
        assertFalse(log.getOutput().contains("tiny-tiny"));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world", "tiny-tiny");
        checkVenvContentsFile(contents, "0.1", "hello-world", "tiny-tiny");

        // remove tiny-tiny, assert that venv wasn't created and only tiny-tiny was removed
        log.clearOutput();
        createVenv(venvDir, "0.1", log, requirements, "hello-world");
        assertTrue(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), false);
        assertFalse(log.getOutput().contains("pip install"));
        assertFalse(log.getOutput().contains("hello-world"));
        assertTrue(log.getOutput().contains("Uninstalling tiny-tiny"));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world");
        checkVenvContentsFile(contents, "0.1", "hello-world");

        // install only hello-world again, assert that venv wasn't created and packages weren't
        // installed
        log.clearOutput();
        createVenv(venvDir, "0.1", log, requirements, "hello-world");
        assertTrue(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), false);
        assertFalse(log.getOutput().contains("pip install"));
        assertFalse(log.getOutput().contains("hello-world"));
        assertFalse(log.getOutput().contains("tiny-tiny"));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world");
        checkVenvContentsFile(contents, "0.1", "hello-world");

        // change version, assert that new venv created and packages installed
        log.clearOutput();
        createVenv(venvDir, "0.2", log, requirements, "hello-world");
        assertTrue(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), true);
        assertTrue(log.getOutput().contains("Stale GraalPy venv, updating to"));
        assertTrue(log.getOutput().contains("pip install"));
        assertTrue(log.getOutput().contains("hello-world"));
        assertFalse(log.getOutput().contains("tiny-tiny"));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world");
        checkVenvContentsFile(contents, "0.2", "hello-world");
    }

    /**
     * when called from jbang, which does not work with requirements file
     */
    @Test
    public void testWithoutRequirementsFile() throws IOException {
        TestLog log = new TestLog();
        Path tmpDir = Files.createTempDirectory("VFSUtilsTest_testWithoutRequirementsFile");
        Path venvDir = tmpDir.resolve("venv");
        Path contents = venvDir.resolve("contents");
        deleteDirOnShutdown(tmpDir);

        createVenv(venvDir, "0.1", log);
        assertFalse(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), false);
        assertFalse(log.getOutput().contains("pip install"));
        log.clearOutput();

        createVenv(venvDir, "0.1", log, "hello-world");
        assertTrue(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), true);
        checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world");
        checkVenvContentsFile(contents, "0.1", "hello-world");
        log.clearOutput();

        createVenv(venvDir, "0.1", log, "hello-world==0.1");
        assertTrue(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), false);
        checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world==0.1");
        checkVenvContentsFile(contents, "0.1", "hello-world==0.1");
        log.clearOutput();

        createVenv(venvDir, "0.1", log, "hello-world", "tiny-tiny");
        assertTrue(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), false);
        checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world", "tiny-tiny");
        checkVenvContentsFile(contents, "0.1", "hello-world", "tiny-tiny");
        log.clearOutput();

        createVenv(venvDir, "0.1", log, "hello-world");
        assertTrue(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), false);
        checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world");
        checkVenvContentsFile(contents, "0.1", "hello-world");
        log.clearOutput();

        // new graalPy version
        createVenv(venvDir, "0.2", log, "hello-world");
        checkVenvCreate(log.getOutput(), true);
        assertTrue(log.getOutput().contains("Stale GraalPy venv, updating to"));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world");
        checkVenvContentsFile(contents, "0.2", "hello-world");
        log.clearOutput();
    }

    @Test
    public void emptyRequirements() throws IOException {
        TestLog log = new TestLog();
        Path tmpDir = Files.createTempDirectory("VFSUtilsTest_emptyRequirements");
        Path venvDir = tmpDir.resolve("venv");
        deleteDirOnShutdown(tmpDir);

        Path requirements = tmpDir.resolve("requirements.txt");
        Files.createFile(requirements);

        checkException(IOException.class, () -> createVenv(venvDir, "0.1", log, requirements, "hello-world"));
        assertFalse(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), false);
        assertTrue(log.getOutput().contains(String.format(WRONG_PKG_VERSION_ERROR, "'hello-world'")));
        assertFalse(log.getOutput().contains("pip install"));
        log.clearOutput();

        createVenv(venvDir, "0.1", log, requirements);
        assertFalse(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), false);
        assertFalse(log.getOutput().contains("pip install"));
        log.clearOutput();

        createVenv(venvDir, "0.2", log, requirements);
        assertFalse(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), false);
        assertFalse(log.getOutput().contains("pip install"));
        log.clearOutput();
    }

    /**
     * python packages managed only by requirements file
     */
    @Test
    public void onlyRequirementsFile() throws IOException {
        TestLog log = new TestLog();
        Path tmpDir = Files.createTempDirectory("VFSUtilsTest_onlyRequirementsFile");
        Path venvDir = tmpDir.resolve("venv");
        Path contents = venvDir.resolve("contents");
        deleteDirOnShutdown(tmpDir);

        Path requirements = tmpDir.resolve("requirements.txt");

        writeRequirementsFile(requirements);
        createVenv(venvDir, "0.1", log, requirements);
        assertFalse(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), false);
        assertFalse(log.getOutput().contains("pip install"));
        assertFalse(Files.exists(venvDir.resolve("installed.txt")));
        log.clearOutput();

        writeRequirementsFile(requirements, "hello-world");
        createVenv(venvDir, "0.1", log, requirements);
        assertTrue(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), true);
        assertTrue(log.getOutput().contains("pip install -r"));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world");
        checkVenvContentsFile(contents, "0.1");
        log.clearOutput();

        writeRequirementsFile(requirements, "tiny-tiny");
        createVenv(venvDir, "0.1", log, requirements);
        assertTrue(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), false);
        assertTrue(log.getOutput().contains("pip install -r"));
        assertTrue(log.getOutput().contains("pip uninstall"));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "tiny-tiny");
        checkVenvContentsFile(contents, "0.1");
        log.clearOutput();

        writeRequirementsFile(requirements, "tiny-tiny", "hello-world");
        createVenv(venvDir, "0.1", log, requirements);
        assertTrue(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), false);
        assertTrue(log.getOutput().contains("pip install -r"));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world", "tiny-tiny");
        checkVenvContentsFile(contents, "0.1");
        log.clearOutput();

        writeRequirementsFile(requirements, "tiny-tiny==0.1", "hello-world");
        createVenv(venvDir, "0.1", log, requirements);
        assertTrue(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), false);
        assertTrue(log.getOutput().contains("pip install -r"));
        assertTrue(log.getOutput().contains("pip uninstall"));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world", "tiny-tiny==0.1");
        checkVenvContentsFile(contents, "0.1");
        log.clearOutput();

        // new graalpy version
        createVenv(venvDir, "0.2", log, requirements);
        checkVenvCreate(log.getOutput(), true);
        assertTrue(log.getOutput().contains("Stale GraalPy venv, updating to"));
        assertTrue(log.getOutput().contains("pip install -r"));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world", "tiny-tiny==0.1");
        checkVenvContentsFile(contents, "0.2");
        log.clearOutput();

        // check that freeze rewrites an existing requirements file
        writeRequirementsFile(requirements); // no packages
        freeze(venvDir, requirements, log, "hello-world==0.1", "tiny-tiny==0.1");
        checkRequirementsFile(requirements, "hello-world==0.1", "tiny-tiny==0.1");
        log.clearOutput();
    }

    private static void freeze(Path venvDir, Path requirements, TestLog log, String... packages) throws IOException {
        VFSUtils.freezePackages(venvDir, Arrays.asList(packages), requirements, REQUIREMENTS_HEADER, WRONG_PKG_VERSION_ERROR, createLauncher(venvDir), "0.1", log);
    }

    private static void writeRequirementsFile(Path requirements, String... packages) throws IOException {
        List<String> lines = new ArrayList<>(Arrays.asList("# " + String.join("\n# ", REQUIREMENTS_HEADER.split("\n"))));
        lines.addAll(Arrays.asList(packages));
        Files.write(requirements, lines, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
    }

    @Test
    public void missingRequirementsWarning() throws IOException {
        TestLog log = new TestLog();
        Path tmpDir = Files.createTempDirectory("VFSUtilsTest_missingRequirementsWarning");
        Path venvDir = tmpDir.resolve("venv");
        Path contents = venvDir.resolve("contents");
        deleteDirOnShutdown(tmpDir);

        Path requirements = tmpDir.resolve("requirements.txt");

        // install request, it pulls in transitive pkgs and we get the missing requirements file
        // warning
        createVenv(venvDir, "0.1", log, requirements, "requests==2.32.3");
        assertTrue(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), true);
        checkInstalledPackages(venvDir.resolve("installed.txt"), "requests==2.32.3", "charset-normalizer", "idna", "urllib3", "certifi");
        checkVenvContentsFile(contents, "0.1", "requests==2.32.3");
        assertTrue(log.getOutput().contains(MISSING_REQUIREMENTS_FILE_WARNING));
        log.clearOutput();

        // freeze requirements
        freeze(venvDir, requirements, log, "requests==2.32.3");
        checkRequirementsFile(requirements, "requests==2.32.3", "charset-normalizer", "idna", "urllib3", "certifi");
        assertFalse(log.getOutput().contains(MISSING_REQUIREMENTS_FILE_WARNING));
        log.clearOutput();

        // install again - no more warning
        delete(venvDir);
        createVenv(venvDir, "0.1", log, requirements, "requests==2.32.3");
        assertTrue(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), true);
        checkInstalledPackages(venvDir.resolve("installed.txt"), "requests==2.32.3", "charset-normalizer", "idna", "urllib3", "certifi");
        checkVenvContentsFile(contents, "0.1", "requests==2.32.3");
        assertFalse(log.getOutput().contains(MISSING_REQUIREMENTS_FILE_WARNING));
    }

    @Test
    public void installAndFreeze() throws IOException {
        TestLog log = new TestLog();
        Path tmpDir = Files.createTempDirectory("VFSUtilsTest_installAndFreeze");
        Path venvDir = tmpDir.resolve("venv");
        Path contents = venvDir.resolve("contents");
        deleteDirOnShutdown(tmpDir);

        Path requirements = tmpDir.resolve("requirements.txt");

        // install package from plugin config
        createVenv(venvDir, "0.1", log, requirements, "hello-world==0.2");
        assertTrue(Files.exists(venvDir));
        checkVenvCreate(log.getOutput(), true);
        checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world");
        checkVenvContentsFile(contents, "0.1", "hello-world==0.2");
        assertFalse(log.getOutput().contains(MISSING_REQUIREMENTS_FILE_WARNING));
        log.clearOutput();

        // freeze requirements without version - fails
        checkException(IOException.class, () -> freeze(venvDir, requirements, log, "hello-world"));
        assertFalse(Files.exists(requirements));
        assertFalse(log.getOutput().contains(String.format(WRONG_PKG_VERSION_ERROR, "hello-world")));
        assertFalse(log.getOutput().contains(MISSING_REQUIREMENTS_FILE_WARNING));
        // freeze requirements with version - ok
        freeze(venvDir, requirements, log, "hello-world==0.2");
        checkRequirementsFile(requirements, "hello-world==0.2");
        assertFalse(log.getOutput().contains(MISSING_REQUIREMENTS_FILE_WARNING));
        log.clearOutput();

        // reinstall without exact version declared - fails
        checkException(IOException.class, () -> createVenv(venvDir, "0.1", log, requirements, "hello-world"));
        checkVenvCreate(log.getOutput(), false);
        assertTrue(log.getOutput().contains(String.format(WRONG_PKG_VERSION_ERROR, "'hello-world'")));
        assertFalse(log.getOutput().contains("pip install"));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world==0.2");
        checkVenvContentsFile(contents, "0.1", "hello-world==0.2");
        assertFalse(log.getOutput().contains(MISSING_REQUIREMENTS_FILE_WARNING));
        log.clearOutput();

        // reinstall with exact version declared - ok
        Files.delete(requirements);
        createVenv(venvDir, "0.1", log, requirements, "hello-world==0.1");
        checkVenvCreate(log.getOutput(), false);
        assertTrue(log.getOutput().contains("pip install"));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world==0.1");
        checkVenvContentsFile(contents, "0.1", "hello-world==0.1");
        assertFalse(log.getOutput().contains(MISSING_REQUIREMENTS_FILE_WARNING));
        log.clearOutput();
        // freeze requirements
        freeze(venvDir, requirements, log, "hello-world==0.1");
        checkRequirementsFile(requirements, "hello-world==0.1");
        assertFalse(log.getOutput().contains(MISSING_REQUIREMENTS_FILE_WARNING));
        log.clearOutput();

        // add tiny-tiny - fails because inconsistent with requirements file
        assert Files.exists(requirements);
        checkException(IOException.class, () -> createVenv(venvDir, "0.1", log, requirements, "hello-world==0.1", "tiny-tiny==0.2"));
        checkVenvCreate(log.getOutput(), false);
        assertFalse(log.getOutput().contains("pip install"));
        assertTrue(log.getOutput().contains(String.format(INCONSISTENT_PKGS_ERROR, requirements, "'tiny-tiny==0.2'")));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world==0.1");
        checkVenvContentsFile(contents, "0.1", "hello-world==0.1");
        assertFalse(log.getOutput().contains(MISSING_REQUIREMENTS_FILE_WARNING));
        log.clearOutput();

        // delete requirements and try again tiny-tiny - now ok
        Files.delete(requirements);
        createVenv(venvDir, "0.1", log, requirements, "hello-world==0.1", "tiny-tiny==0.2");
        checkVenvCreate(log.getOutput(), false);
        assertTrue(log.getOutput().contains("pip install"));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world==0.1", "tiny-tiny==0.2");
        checkVenvContentsFile(contents, "0.1", "hello-world==0.1", "tiny-tiny==0.2");
        assertFalse(log.getOutput().contains(MISSING_REQUIREMENTS_FILE_WARNING));
        // freeze requirements - hello-world, tiny-tiny
        freeze(venvDir, requirements, log, "hello-world==0.1", "tiny-tiny==0.2");
        checkRequirementsFile(requirements, "hello-world==0.1", "tiny-tiny==0.2");
        assertFalse(log.getOutput().contains(MISSING_REQUIREMENTS_FILE_WARNING));
        log.clearOutput();

        // install again - OK
        createVenv(venvDir, "0.1", log, requirements, "hello-world==0.1", "tiny-tiny==0.2");
        checkVenvCreate(log.getOutput(), false);
        assertFalse(log.getOutput().contains("pip install"));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world==0.1", "tiny-tiny==0.2");
        checkVenvContentsFile(contents, "0.1", "hello-world==0.1", "tiny-tiny==0.2");
        assertFalse(log.getOutput().contains(MISSING_REQUIREMENTS_FILE_WARNING));
        log.clearOutput();

        // update hello-world version - fails
        checkException(IOException.class, () -> createVenv(venvDir, "0.1", log, requirements, "hello-world==0.2", "tiny-tiny==0.2"));
        checkVenvCreate(log.getOutput(), false);
        assertFalse(log.getOutput().contains("pip install"));
        assertTrue(log.getOutput().contains(String.format(INCONSISTENT_PKGS_ERROR, requirements, "'hello-world==0.2'")));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world==0.1", "tiny-tiny==0.2");
        checkVenvContentsFile(contents, "0.1", "hello-world==0.1", "tiny-tiny==0.2");
        assertFalse(log.getOutput().contains(MISSING_REQUIREMENTS_FILE_WARNING));
        log.clearOutput();

        // delete requirements and try again new hello-world version - now ok
        Files.delete(requirements);
        createVenv(venvDir, "0.1", log, requirements, "hello-world==0.2", "tiny-tiny==0.2");
        checkVenvCreate(log.getOutput(), false);
        assertTrue(log.getOutput().contains("pip install"));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world==0.2", "tiny-tiny==0.2");
        checkVenvContentsFile(contents, "0.1", "hello-world==0.2", "tiny-tiny==0.2");
        assertFalse(log.getOutput().contains(MISSING_REQUIREMENTS_FILE_WARNING));
        log.clearOutput();
        // freeze requirements with new hello-world
        freeze(venvDir, requirements, log, "hello-world==0.2", "tiny-tiny==0.2");
        checkRequirementsFile(requirements, "hello-world==0.2", "tiny-tiny==0.2");
        assertFalse(log.getOutput().contains(MISSING_REQUIREMENTS_FILE_WARNING));
        log.clearOutput();

        // install again - OK
        createVenv(venvDir, "0.1", log, requirements, "hello-world==0.2", "tiny-tiny==0.2");
        checkVenvCreate(log.getOutput(), false);
        assertFalse(log.getOutput().contains("pip install"));
        checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world==0.2", "tiny-tiny==0.2");
        checkVenvContentsFile(contents, "0.1", "hello-world==0.2", "tiny-tiny==0.2");
        assertFalse(log.getOutput().contains(MISSING_REQUIREMENTS_FILE_WARNING));
        log.clearOutput();

        // reinstall with new graalpy version
        createVenv(venvDir, "0.2", log, requirements, "hello-world==0.2", "tiny-tiny==0.2");
        checkVenvCreate(log.getOutput(), true);
        assertTrue(log.getOutput().contains("Stale GraalPy venv, updating to"));
        assertTrue(log.getOutput().contains("pip install -r")); // requirements file is used
        checkInstalledPackages(venvDir.resolve("installed.txt"), "hello-world==0.2", "tiny-tiny==0.2");
        checkVenvContentsFile(contents, "0.2", "hello-world==0.2", "tiny-tiny==0.2");
        assertFalse(log.getOutput().contains(MISSING_REQUIREMENTS_FILE_WARNING));
        log.clearOutput();
    }

    // XXX test and fix:
    // - mvn package with 2 pkgs in pom
    // - freeze
    // - remove 1 pkg from pom
    // - mvn package keeps the removed pkg in venv because installing from req file!!!
    // at least warning?

    @Test
    public void invalidVersionFormatTest() {
        TestLog log = new TestLog();

        checkWrongPkgVersionFormat("", log);
        checkWrongPkgVersionFormat("==2.2", log);
        checkWrongPkgVersionFormat("==", log);
        checkWrongPkgVersionFormat("somepkg==", log);

        checkWrongPkgVersionFormat("somepkg", log);
        checkWrongPkgVersionFormat("somepkg==2.*", log);
        checkWrongPkgVersionFormat("==*", log);
        for (String v : new String[]{"", "<=", ">=", "~="}) {
            checkWrongPkgVersionFormat("somepkg" + v + "2.2.0", log);
        }
    }

    private static void checkWrongPkgVersionFormat(String pkg, TestLog log) {
        checkException(IOException.class, () -> VFSUtils.checkVersionFormat(Arrays.asList(pkg), WRONG_PKG_VERSION_ERROR, log));
        assertTrue(log.getOutput().contains(String.format(WRONG_PKG_VERSION_ERROR, "'" + pkg + "'")));
        log.clearOutput();
    }

    @Test
    public void packageConsistency() throws Exception {
        TestLog log = new TestLog();

        Path tmpDir = Files.createTempDirectory("VFSUtilsTest_packageConsistency");
        deleteDirOnShutdown(tmpDir);
        Path requirements = tmpDir.resolve("requirements.txt");
        Files.createFile(requirements);

        callPackageConsistencyCheck(log, Collections.emptyList(), requirements);

        checkException(IOException.class, () -> callPackageConsistencyCheck(log, Collections.emptyList(), requirements, "pkg1"));
        assertTrue(log.getOutput().contains(String.format(WRONG_PKG_VERSION_ERROR, "'pkg1'")));
        log.clearOutput();

        checkException(IOException.class, () -> callPackageConsistencyCheck(log, Collections.emptyList(), requirements, "pkg1==1"));
        assertTrue(log.getOutput().contains(String.format(INCONSISTENT_PKGS_ERROR, requirements, "'pkg1==1'")));
        log.clearOutput();

        final List<String> requirementsList = Arrays.asList("pkg1==1.0.0");
        Files.write(requirements, requirementsList, StandardOpenOption.TRUNCATE_EXISTING);

        checkException(IOException.class, () -> callPackageConsistencyCheck(log, requirementsList, requirements, "pkg1"));
        assertTrue(log.getOutput().contains(String.format(WRONG_PKG_VERSION_ERROR, "'pkg1'")));
        log.clearOutput();
        checkException(IOException.class, () -> callPackageConsistencyCheck(log, requirementsList, requirements, "pkg2"));
        assertTrue(log.getOutput().contains(String.format(WRONG_PKG_VERSION_ERROR, "'pkg2'")));
        log.clearOutput();
        checkException(IOException.class, () -> callPackageConsistencyCheck(log, requirementsList, requirements, "pkg2==1"));
        assertTrue(log.getOutput().contains(String.format(INCONSISTENT_PKGS_ERROR, requirements, "'pkg2==1'")));
        log.clearOutput();
        callPackageConsistencyCheck(log, requirementsList, requirements, "pkg1==1.0");
        log.clearOutput();
        callPackageConsistencyCheck(log, requirementsList, requirements, "pkg1==1.0.0");
        log.clearOutput();

        final List<String> requirementsList2 = Arrays.asList("pkg1==1.0.0", "pkg2==1.0.0");
        Files.write(requirements, requirementsList, StandardOpenOption.TRUNCATE_EXISTING);

        checkException(IOException.class, () -> callPackageConsistencyCheck(log, requirementsList2, requirements, "pkg2"));
        assertTrue(log.getOutput().contains(String.format(WRONG_PKG_VERSION_ERROR, "'pkg2'")));
        log.clearOutput();
        checkException(IOException.class, () -> callPackageConsistencyCheck(log, requirementsList2, requirements, "pkg2==2"));
        assertTrue(log.getOutput().contains(String.format(INCONSISTENT_PKGS_ERROR, requirements, "'pkg2==2'")));
        log.clearOutput();
        callPackageConsistencyCheck(log, requirementsList2, requirements, "pkg1==1.0");
        log.clearOutput();
        callPackageConsistencyCheck(log, requirementsList2, requirements, "pkg1==1.0", "pkg2==1.0.0");
        log.clearOutput();
    }

    private static void callPackageConsistencyCheck(TestLog log, List<String> requirementsList, Path requirements, String... packages)
                    throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        Method m = VFSUtils.class.getDeclaredMethod("checkPackagesConsistent", List.class, List.class, Path.class, String.class, String.class, BuildToolLog.class);
        m.setAccessible(true);
        m.invoke(VFSUtils.class, Arrays.asList(packages), requirementsList, requirements, INCONSISTENT_PKGS_ERROR, WRONG_PKG_VERSION_ERROR, log);
    }

    private interface ExceptionCall {
        void call() throws Exception;
    }

    private static void checkException(Class<?> cls, ExceptionCall c) {
        try {
            c.call();
        } catch (Exception e) {
            if (e instanceof InvocationTargetException) {
                assertEquals(cls, e.getCause().getClass());
            } else {
                assertEquals(cls, e.getClass());
            }
        }
    }

    private static void checkVenvCreate(String output, boolean b) {
        if (b) {
            assertTrue(output.contains("-m venv"));
            assertTrue(output.contains("-m ensurepip"));
        } else {
            assertFalse(output.contains("-m venv"));
            assertFalse(output.contains("-m ensurepip"));
        }
    }

    private static void checkInstalledPackages(Path requirements, String... packages) throws IOException {
        checkPackages(requirements, null, packages);
    }

    private static void checkRequirementsFile(Path requirements, String... packages) throws IOException {
        checkPackages(requirements, REQUIREMENTS_HEADER, packages);
    }

    private static void checkPackages(Path file, String header, String... packages) throws IOException {
        assertTrue(Files.exists(file));
        List<String> lines = Files.readAllLines(file);

        if (header != null) {
            String[] h = header.split("\n");
            assertTrue(lines.size() >= h.length);
            for (int i = 0; i < h.length; i++) {
                assertEquals("# " + h[i], lines.get(i));
            }
        }

        lines = lines.stream().filter(line -> !line.trim().startsWith("#") && !line.trim().isEmpty()).toList();
        assertEquals(packages.length, lines.size());
        for (String pkg : packages) {
            boolean found = false;
            String pkgDef = pkg.indexOf("==") >= 0 ? pkg : pkg + "==";
            for (String line : lines) {
                assert line.contains("==");
                if (line.startsWith(pkgDef)) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                fail("file " + file + " does not contain package " + pkg);
            }
        }
    }

    private static void createVenv(Path venvDir, String graalPyVersion, TestLog log, String... packages) throws IOException {
        EmbeddingTestUtils.createVenv(venvDir, graalPyVersion, log, packages);
    }

    private static void createVenv(Path venvDir, String graalPyVersion, TestLog log, Path requirements, String... packages) throws IOException {
        EmbeddingTestUtils.createVenv(venvDir, graalPyVersion, log, requirements, INCONSISTENT_PKGS_ERROR, WRONG_PKG_VERSION_ERROR, MISSING_REQUIREMENTS_FILE_WARNING, packages);
    }

    private static void checkVenvContentsFile(Path contents, String graalPyVersion, String... packages) throws IOException {
        assertTrue(Files.exists(contents));
        List<String> lines = Files.readAllLines(contents);

        assertEquals(graalPyVersion, lines.get(0));
        lines.remove(0);
        assertEquals(packages.length, lines.size());
        assertTrue(lines.containsAll(Arrays.asList(packages)));
    }

}
