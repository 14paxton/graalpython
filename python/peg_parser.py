#!/usr/bin/env python3.8
# @generated by pegen from ../../Grammar/python.gram

import ast
from typing import Optional, Any

from pegen.parser import memoize, memoize_left_rec, logger, Parser
class GeneratedParser(Parser):

    @memoize
    def file(self) -> Optional[mod_ty]:
        # file: statements? $
        mark = self.mark()
        cut = False
        if (
            (a := self.statements(),)
            and
            (endmarker := self.expect('ENDMARKER'))
        ):
            return _PyPegen_make_module ( p , a )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def interactive(self) -> Optional[mod_ty]:
        # interactive: statement_newline
        mark = self.mark()
        cut = False
        if (
            (a := self.statement_newline())
        ):
            return _PyAST_Interactive ( a , p  )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def eval(self) -> Optional[mod_ty]:
        # eval: expressions NEWLINE* $
        mark = self.mark()
        cut = False
        if (
            (a := self.expressions())
            and
            (_loop0_1 := self._loop0_1(),)
            and
            (endmarker := self.expect('ENDMARKER'))
        ):
            return _PyAST_Expression ( a , p  )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def func_type(self) -> Optional[mod_ty]:
        # func_type: '(' type_expressions? ')' '->' expression NEWLINE* $
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('('))
            and
            (a := self.type_expressions(),)
            and
            (literal_1 := self.expect(')'))
            and
            (literal_2 := self.expect('->'))
            and
            (b := self.expression())
            and
            (_loop0_2 := self._loop0_2(),)
            and
            (endmarker := self.expect('ENDMARKER'))
        ):
            return _PyAST_FunctionType ( a , b , p  )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def fstring(self) -> Optional[expr_ty]:
        # fstring: star_expressions
        mark = self.mark()
        cut = False
        if (
            (star_expressions := self.star_expressions())
        ):
            return [star_expressions]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def type_expressions(self):
        # type_expressions: ','.expression+ ',' '*' expression ',' '**' expression | ','.expression+ ',' '*' expression | ','.expression+ ',' '**' expression | '*' expression ',' '**' expression | '*' expression | '**' expression | ','.expression+
        mark = self.mark()
        cut = False
        if (
            (a := self._gather_3())
            and
            (literal := self.expect(','))
            and
            (literal_1 := self.expect('*'))
            and
            (b := self.expression())
            and
            (literal_2 := self.expect(','))
            and
            (literal_3 := self.expect('**'))
            and
            (c := self.expression())
        ):
            return  _PyPegen_seq_append_to_end ( p , CHECK ( asdl_seq * , _PyPegen_seq_append_to_end ( p , a , b ) ) , c )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self._gather_5())
            and
            (literal := self.expect(','))
            and
            (literal_1 := self.expect('*'))
            and
            (b := self.expression())
        ):
            return ( asdl_expr_seq * ) _PyPegen_seq_append_to_end ( p , a , b )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self._gather_7())
            and
            (literal := self.expect(','))
            and
            (literal_1 := self.expect('**'))
            and
            (b := self.expression())
        ):
            return ( asdl_expr_seq * ) _PyPegen_seq_append_to_end ( p , a , b )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('*'))
            and
            (a := self.expression())
            and
            (literal_1 := self.expect(','))
            and
            (literal_2 := self.expect('**'))
            and
            (b := self.expression())
        ):
            return ( asdl_expr_seq * ) _PyPegen_seq_append_to_end ( p , CHECK ( asdl_seq * , _PyPegen_singleton_seq ( p , a ) ) , b )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('*'))
            and
            (a := self.expression())
        ):
            return ( asdl_expr_seq * ) _PyPegen_singleton_seq ( p , a )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('**'))
            and
            (a := self.expression())
        ):
            return ( asdl_expr_seq * ) _PyPegen_singleton_seq ( p , a )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self._gather_9())
        ):
            return a
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def statements(self) -> Optional[asdl_stmt_seq*]:
        # statements: statement+
        mark = self.mark()
        cut = False
        if (
            (a := self._loop1_11())
        ):
            return ( asdl_stmt_seq * ) _PyPegen_seq_flatten ( p , a )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def statement(self) -> Optional[asdl_stmt_seq*]:
        # statement: compound_stmt | simple_stmts
        mark = self.mark()
        cut = False
        if (
            (a := self.compound_stmt())
        ):
            return ( asdl_stmt_seq * ) _PyPegen_singleton_seq ( p , a )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.simple_stmts())
        ):
            return a
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def statement_newline(self) -> Optional[asdl_stmt_seq*]:
        # statement_newline: compound_stmt NEWLINE | simple_stmts | NEWLINE | $
        mark = self.mark()
        cut = False
        if (
            (a := self.compound_stmt())
            and
            (newline := self.expect('NEWLINE'))
        ):
            return ( asdl_stmt_seq * ) _PyPegen_singleton_seq ( p , a )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (simple_stmts := self.simple_stmts())
        ):
            return [simple_stmts]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (newline := self.expect('NEWLINE'))
        ):
            return ( asdl_stmt_seq * ) _PyPegen_singleton_seq ( p , CHECK ( stmt_ty , _PyAST_Pass ( EXTRA ) ) )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (endmarker := self.expect('ENDMARKER'))
        ):
            return _PyPegen_interactive_exit ( p )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def simple_stmts(self) -> Optional[asdl_stmt_seq*]:
        # simple_stmts: simple_stmt !';' NEWLINE | ';'.simple_stmt+ ';'? NEWLINE
        mark = self.mark()
        cut = False
        if (
            (a := self.simple_stmt())
            and
            self.negative_lookahead(self.expect, ';')
            and
            (newline := self.expect('NEWLINE'))
        ):
            return ( asdl_stmt_seq * ) _PyPegen_singleton_seq ( p , a )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self._gather_12())
            and
            (opt := self.expect(';'),)
            and
            (newline := self.expect('NEWLINE'))
        ):
            return a
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def simple_stmt(self) -> Optional[stmt_ty]:
        # simple_stmt: assignment | star_expressions | &'return' return_stmt | &('import' | 'from') import_stmt | &'raise' raise_stmt | 'pass' | &'del' del_stmt | &'yield' yield_stmt | &'assert' assert_stmt | 'break' | 'continue' | &'global' global_stmt | &'nonlocal' nonlocal_stmt
        mark = self.mark()
        cut = False
        if (
            (assignment := self.assignment())
        ):
            return [assignment]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (e := self.star_expressions())
        ):
            return _PyAST_Expr ( e , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.positive_lookahead(self.expect, 'return')
            and
            (return_stmt := self.return_stmt())
        ):
            return [return_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.positive_lookahead(self._tmp_14, )
            and
            (import_stmt := self.import_stmt())
        ):
            return [import_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.positive_lookahead(self.expect, 'raise')
            and
            (raise_stmt := self.raise_stmt())
        ):
            return [raise_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('pass'))
        ):
            return _PyAST_Pass ( EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.positive_lookahead(self.expect, 'del')
            and
            (del_stmt := self.del_stmt())
        ):
            return [del_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.positive_lookahead(self.expect, 'yield')
            and
            (yield_stmt := self.yield_stmt())
        ):
            return [yield_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.positive_lookahead(self.expect, 'assert')
            and
            (assert_stmt := self.assert_stmt())
        ):
            return [assert_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('break'))
        ):
            return _PyAST_Break ( EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('continue'))
        ):
            return _PyAST_Continue ( EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.positive_lookahead(self.expect, 'global')
            and
            (global_stmt := self.global_stmt())
        ):
            return [global_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.positive_lookahead(self.expect, 'nonlocal')
            and
            (nonlocal_stmt := self.nonlocal_stmt())
        ):
            return [nonlocal_stmt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def compound_stmt(self) -> Optional[stmt_ty]:
        # compound_stmt: &('def' | '@' | ASYNC) function_def | &'if' if_stmt | &('class' | '@') class_def | &('with' | ASYNC) with_stmt | &('for' | ASYNC) for_stmt | &'try' try_stmt | &'while' while_stmt | match_stmt
        mark = self.mark()
        cut = False
        if (
            self.positive_lookahead(self._tmp_15, )
            and
            (function_def := self.function_def())
        ):
            return [function_def]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.positive_lookahead(self.expect, 'if')
            and
            (if_stmt := self.if_stmt())
        ):
            return [if_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.positive_lookahead(self._tmp_16, )
            and
            (class_def := self.class_def())
        ):
            return [class_def]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.positive_lookahead(self._tmp_17, )
            and
            (with_stmt := self.with_stmt())
        ):
            return [with_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.positive_lookahead(self._tmp_18, )
            and
            (for_stmt := self.for_stmt())
        ):
            return [for_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.positive_lookahead(self.expect, 'try')
            and
            (try_stmt := self.try_stmt())
        ):
            return [try_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            self.positive_lookahead(self.expect, 'while')
            and
            (while_stmt := self.while_stmt())
        ):
            return [while_stmt]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (match_stmt := self.match_stmt())
        ):
            return [match_stmt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def assignment(self) -> Optional[stmt_ty]:
        # assignment: NAME ':' expression ['=' annotated_rhs] | ('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' annotated_rhs] | ((star_targets '='))+ (yield_expr | star_expressions) !'=' TYPE_COMMENT? | single_target augassign ~ (yield_expr | star_expressions) | invalid_assignment
        mark = self.mark()
        cut = False
        if (
            (a := self.name())
            and
            (literal := self.expect(':'))
            and
            (b := self.expression())
            and
            (c := self._tmp_19(),)
        ):
            return CHECK_VERSION ( stmt_ty , 6 , "Variable annotation syntax is" , _PyAST_AnnAssign ( CHECK ( expr_ty , _PyPegen_set_expr_context ( p , a , Store ) ) , b , c , 1 , EXTRA ) )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self._tmp_20())
            and
            (literal := self.expect(':'))
            and
            (b := self.expression())
            and
            (c := self._tmp_21(),)
        ):
            return CHECK_VERSION ( stmt_ty , 6 , "Variable annotations syntax is" , _PyAST_AnnAssign ( a , b , c , 0 , EXTRA ) )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self._loop1_22())
            and
            (b := self._tmp_23())
            and
            self.negative_lookahead(self.expect, '=')
            and
            (tc := self.TYPE_COMMENT(),)
        ):
            return _PyAST_Assign ( a , b , NEW_TYPE_COMMENT ( p , tc ) , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (a := self.single_target())
            and
            (b := self.augassign())
            and
            (cut := True)
            and
            (c := self._tmp_24())
        ):
            return _PyAST_AugAssign ( a , b -> kind , c , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (invalid_assignment := self.invalid_assignment())
        ):
            return [invalid_assignment]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def augassign(self) -> Optional[AugOperator*]:
        # augassign: '+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=' | '**=' | '//='
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('+='))
        ):
            return _PyPegen_augoperator ( p , Add )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('-='))
        ):
            return _PyPegen_augoperator ( p , Sub )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('*='))
        ):
            return _PyPegen_augoperator ( p , Mult )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('@='))
        ):
            return CHECK_VERSION ( AugOperator * , 5 , "The '@' operator is" , _PyPegen_augoperator ( p , MatMult ) )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('/='))
        ):
            return _PyPegen_augoperator ( p , Div )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('%='))
        ):
            return _PyPegen_augoperator ( p , Mod )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('&='))
        ):
            return _PyPegen_augoperator ( p , BitAnd )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('|='))
        ):
            return _PyPegen_augoperator ( p , BitOr )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('^='))
        ):
            return _PyPegen_augoperator ( p , BitXor )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('<<='))
        ):
            return _PyPegen_augoperator ( p , LShift )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('>>='))
        ):
            return _PyPegen_augoperator ( p , RShift )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('**='))
        ):
            return _PyPegen_augoperator ( p , Pow )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('//='))
        ):
            return _PyPegen_augoperator ( p , FloorDiv )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def global_stmt(self) -> Optional[stmt_ty]:
        # global_stmt: 'global' ','.NAME+
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('global'))
            and
            (a := self._gather_25())
        ):
            return _PyAST_Global ( CHECK ( asdl_identifier_seq * , _PyPegen_map_names_to_ids ( p , a ) ) , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def nonlocal_stmt(self) -> Optional[stmt_ty]:
        # nonlocal_stmt: 'nonlocal' ','.NAME+
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('nonlocal'))
            and
            (a := self._gather_27())
        ):
            return _PyAST_Nonlocal ( CHECK ( asdl_identifier_seq * , _PyPegen_map_names_to_ids ( p , a ) ) , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def yield_stmt(self) -> Optional[stmt_ty]:
        # yield_stmt: yield_expr
        mark = self.mark()
        cut = False
        if (
            (y := self.yield_expr())
        ):
            return _PyAST_Expr ( y , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def assert_stmt(self) -> Optional[stmt_ty]:
        # assert_stmt: 'assert' expression [',' expression]
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('assert'))
            and
            (a := self.expression())
            and
            (b := self._tmp_29(),)
        ):
            return _PyAST_Assert ( a , b , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def del_stmt(self) -> Optional[stmt_ty]:
        # del_stmt: 'del' del_targets &(';' | NEWLINE) | invalid_del_stmt
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('del'))
            and
            (a := self.del_targets())
            and
            self.positive_lookahead(self._tmp_30, )
        ):
            return _PyAST_Delete ( a , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (invalid_del_stmt := self.invalid_del_stmt())
        ):
            return [invalid_del_stmt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def import_stmt(self) -> Optional[stmt_ty]:
        # import_stmt: import_name | import_from
        mark = self.mark()
        cut = False
        if (
            (import_name := self.import_name())
        ):
            return [import_name]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (import_from := self.import_from())
        ):
            return [import_from]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def import_name(self) -> Optional[stmt_ty]:
        # import_name: 'import' dotted_as_names
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('import'))
            and
            (a := self.dotted_as_names())
        ):
            return _PyAST_Import ( a , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def import_from(self) -> Optional[stmt_ty]:
        # import_from: 'from' (('.' | '...'))* dotted_name 'import' import_from_targets | 'from' (('.' | '...'))+ 'import' import_from_targets
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('from'))
            and
            (a := self._loop0_31(),)
            and
            (b := self.dotted_name())
            and
            (literal_1 := self.expect('import'))
            and
            (c := self.import_from_targets())
        ):
            return _PyAST_ImportFrom ( b -> v . Name . id , c , _PyPegen_seq_count_dots ( a ) , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('from'))
            and
            (a := self._loop1_32())
            and
            (literal_1 := self.expect('import'))
            and
            (b := self.import_from_targets())
        ):
            return _PyAST_ImportFrom ( NULL , b , _PyPegen_seq_count_dots ( a ) , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def import_from_targets(self) -> Optional[asdl_alias_seq*]:
        # import_from_targets: '(' import_from_as_names ','? ')' | import_from_as_names !',' | '*' | invalid_import_from_targets
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('('))
            and
            (a := self.import_from_as_names())
            and
            (opt := self.expect(','),)
            and
            (literal_1 := self.expect(')'))
        ):
            return a
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (import_from_as_names := self.import_from_as_names())
            and
            self.negative_lookahead(self.expect, ',')
        ):
            return [import_from_as_names]
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('*'))
        ):
            return ( asdl_alias_seq * ) _PyPegen_singleton_seq ( p , CHECK ( alias_ty , _PyPegen_alias_for_star ( p , EXTRA ) ) )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (invalid_import_from_targets := self.invalid_import_from_targets())
        ):
            return [invalid_import_from_targets]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def import_from_as_names(self) -> Optional[asdl_alias_seq*]:
        # import_from_as_names: ','.import_from_as_name+
        mark = self.mark()
        cut = False
        if (
            (a := self._gather_33())
        ):
            return a
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def import_from_as_name(self) -> Optional[alias_ty]:
        # import_from_as_name: NAME ['as' NAME]
        mark = self.mark()
        cut = False
        if (
            (a := self.name())
            and
            (b := self._tmp_35(),)
        ):
            return _PyAST_alias ( a -> v . Name . id , ( b ) ? ( ( expr_ty ) b ) -> v . Name . id : NULL , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def dotted_as_names(self) -> Optional[asdl_alias_seq*]:
        # dotted_as_names: ','.dotted_as_name+
        mark = self.mark()
        cut = False
        if (
            (a := self._gather_36())
        ):
            return a
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def dotted_as_name(self) -> Optional[alias_ty]:
        # dotted_as_name: dotted_name ['as' NAME]
        mark = self.mark()
        cut = False
        if (
            (a := self.dotted_name())
            and
            (b := self._tmp_38(),)
        ):
            return _PyAST_alias ( a -> v . Name . id , ( b ) ? ( ( expr_ty ) b ) -> v . Name . id : NULL , EXTRA )
        self.reset(mark)
        if cut: return None
        return None

    @memoize_left_rec
    def dotted_name(self) -> Optional[expr_ty]:
        # dotted_name: dotted_name '.' NAME | NAME
        mark = self.mark()
        cut = False
        if (
            (a := self.dotted_name())
            and
            (literal := self.expect('.'))
            and
            (b := self.name())
        ):
            return _PyPegen_join_names_with_dot ( p , a , b )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (name := self.name())
        ):
            return [name]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def if_stmt(self) -> Optional[stmt_ty]:
        # if_stmt: 'if' named_expression ':' block elif_stmt | 'if' named_expression ':' block else_block? | invalid_if_stmt
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('if'))
            and
            (a := self.named_expression())
            and
            (literal_1 := self.expect(':'))
            and
            (b := self.block())
            and
            (c := self.elif_stmt())
        ):
            return _PyAST_If ( a , b , CHECK ( asdl_stmt_seq * , _PyPegen_singleton_seq ( p , c ) ) , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('if'))
            and
            (a := self.named_expression())
            and
            (literal_1 := self.expect(':'))
            and
            (b := self.block())
            and
            (c := self.else_block(),)
        ):
            return _PyAST_If ( a , b , c , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (invalid_if_stmt := self.invalid_if_stmt())
        ):
            return [invalid_if_stmt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def elif_stmt(self) -> Optional[stmt_ty]:
        # elif_stmt: 'elif' named_expression ':' block elif_stmt | 'elif' named_expression ':' block else_block? | invalid_elif_stmt
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('elif'))
            and
            (a := self.named_expression())
            and
            (literal_1 := self.expect(':'))
            and
            (b := self.block())
            and
            (c := self.elif_stmt())
        ):
            return _PyAST_If ( a , b , CHECK ( asdl_stmt_seq * , _PyPegen_singleton_seq ( p , c ) ) , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('elif'))
            and
            (a := self.named_expression())
            and
            (literal_1 := self.expect(':'))
            and
            (b := self.block())
            and
            (c := self.else_block(),)
        ):
            return _PyAST_If ( a , b , c , EXTRA )
        self.reset(mark)
        if cut: return None
        cut = False
        if (
            (invalid_elif_stmt := self.invalid_elif_stmt())
        ):
            return [invalid_elif_stmt]
        self.reset(mark)
        if cut: return None
        return None

    @memoize
    def else_block(self) -> Optional[asdl_stmt_seq*]:
        # else_block: 'else' &&':' block
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect('else'))
            and
