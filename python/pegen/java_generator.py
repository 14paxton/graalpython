import ast
import token
from typing import Any, Dict, Optional, IO, Text, Tuple
from dataclasses import field, dataclass
from typing import Any, Dict, IO, Optional, List, Text, Tuple, Set
from enum import Enum

from pegen.grammar import (
    Cut,
    GrammarVisitor,
    NameLeaf,
    StringLeaf,
    Rhs,
    NamedItem,
    Lookahead,
    PositiveLookahead,
    NegativeLookahead,
    Opt,
    Repeat0,
    Repeat1,
    Gather,
    Group,
    Rule,
    Alt,
)
from pegen import grammar
from pegen.parser_generator import ParserGenerator

MODULE_PREFIX = """\
#!/usr/bin/env python3.8
# @generated by pegen from {filename}

import ast
from typing import Optional, Any

from pegen.parser import memoize, memoize_left_rec, logger, Parser

"""
MODULE_SUFFIX = """

if __name__ == '__main__':
    from pegen.parser import simple_parser_main
    simple_parser_main(GeneratedParser)
"""

class NodeTypes(Enum):
    NAME_TOKEN = 0
    NUMBER_TOKEN = 1
    STRING_TOKEN = 2
    GENERIC_TOKEN = 3
    KEYWORD = 4
    SOFT_KEYWORD = 5
    CUT_OPERATOR = 6

BASE_NODETYPES = {
    "NAME": NodeTypes.NAME_TOKEN,
    "NUMBER": NodeTypes.NUMBER_TOKEN,
    "STRING": NodeTypes.STRING_TOKEN,
    "SOFT_KEYWORD": NodeTypes.SOFT_KEYWORD,
}
    
@dataclass
class FunctionCall:
    function: str
    arguments: List[Any] = field(default_factory=list)
    assigned_variable: Optional[str] = None
    assigned_variable_type: Optional[str] = None
    return_type: Optional[str] = None
    nodetype: Optional[NodeTypes] = None
    force_true: bool = False
    comment: Optional[str] = None

    def __str__(self) -> str:
        parts = []
        parts.append(self.function)
        if self.arguments:
            parts.append(f"({', '.join(map(str, self.arguments))})")
        if self.force_true:
            parts.append(", 1")
        if self.assigned_variable:
            if self.assigned_variable_type:
                parts = ["(", self.assigned_variable, " = ", '(', self.assigned_variable_type, ')', *parts, ")"]
            else:
                parts = ["(", self.assigned_variable, " = ", *parts, ")"]
        if self.comment:
            parts.append(f"  // {self.comment}")
        
        return "".join(parts)


    
class JavaCallMakerVisitor(GrammarVisitor):
    def __init__(
        self, 
        parser_generator: ParserGenerator,
        exact_tokens: Dict[str, int],
        non_exact_tokens: Set[str],
    ):
        self.gen = parser_generator
        self.exact_tokens = exact_tokens
        self.non_exact_tokens = non_exact_tokens
        self.cache: Dict[Any, Any] = {}
        self.indent = 0;

    def keyword_helper(self, keyword: str) -> FunctionCall:
        if keyword not in self.keyword_cache:
            self.keyword_cache[keyword] = self.gen.keyword_type()
        return FunctionCall(
            assigned_variable="_keyword",
            function="_PyPegen_expect_token",
            arguments=["p", self.keyword_cache[keyword]],
            return_type="Token *",
            nodetype=NodeTypes.KEYWORD,
            comment=f"token='{keyword}'",
        )

    def soft_keyword_helper(self, value: str) -> FunctionCall:
        self.soft_keywords.add(value.replace('"', ""))
        return FunctionCall(
            assigned_variable="_keyword",
            function="_PyPegen_expect_soft_keyword",
            arguments=["p", value],
            return_type="expr_ty",
            nodetype=NodeTypes.SOFT_KEYWORD,
            comment=f"soft_keyword='{value}'",
        )
        
    def visit_NameLeaf(self, node: NameLeaf) -> FunctionCall:
        print(self.create_indent(), "JavaCallMakerVisitor.visit_NameLeaf" , node)
        self.indent += 2
        name = node.value
        print(self.create_indent(), "name: " , name)
        #if name in ("NAME", "NUMBER", "STRING", "OP"):
        #    name = name.lower()
        #    return name, f"self.{name}()"
        #if name in ("NEWLINE", "DEDENT", "INDENT", "ENDMARKER", "ASYNC", "AWAIT"):
        #    return name.lower(), f"self.expect({name!r})"
        #return name, f"self.{name}()"
        type = None
        result = FunctionCall(
            assigned_variable=f"{name}_var",
            function=f"{name}_rule",
            arguments=["p"],
            return_type=type,
            comment=f"{node}",
        )
        print(self.create_indent(), "result:" , result)
        self.indent -= 2
        return result

    def visit_StringLeaf(self, node: StringLeaf) -> FunctionCall:
        print(self.create_indent(), "JavaCallMakerVisitor.visit_NameLeaf", node)
        self.indent += 2
        val = ast.literal_eval(node.value)
        print(self.create_indent(), "val:", val)
        #result = "literal", f"self.expect({node.value})"
        type = self.exact_tokens[val]
        result = FunctionCall(
                assigned_variable="_literal",
                function=f"_PyPegen_expect_token",
                arguments=["p", type],
                nodetype=NodeTypes.GENERIC_TOKEN,
                return_type="Token *",
                comment=f"token='{val}'",
            )
        print(self.create_indent(),"result:", result)
        self.indent -= 2
        return result

    def visit_Rhs(self, node: Rhs) -> FunctionCall:
        print(self.create_indent(), "JavaCallMakerVisitor.visit_Rhs:", node)
        self.indent += 2
        if node in self.cache:
            return self.cache[node]
        if len(node.alts) == 1 and len(node.alts[0].items) == 1:
            self.cache[node] = self.visit(node.alts[0].items[0])
        else:
            name = self.gen.name_node(node)
            self.cache[node] = name, f"self.{name}()"
        result = self.cache[node]
        print(self.create_indent(),"result:", result)
        self.indent -= 2   
        return result

    def visit_NamedItem(self, node: NamedItem) -> FunctionCall:
        print(self.create_indent(), "JavaCallMakerVisitor.visit_NamedItem:", node)
        self.indent += 2
        call = self.generate_call(node.item)
        if node.name:
            call.assigned_variable = node.name
        if node.type:
            call.assigned_variable_type = node.type
        print(self.create_indent(), "result call:", call)
        self.indent -= 2
        return call

    def lookahead_call_helper(self, node: Lookahead, positive: int) -> FunctionCall:
        call = self.generate_call(node.node)
        if call.nodetype == NodeTypes.NAME_TOKEN:
            return FunctionCall(
                function=f"_PyPegen_lookahead_with_name",
                arguments=[positive, call.function, *call.arguments],
                return_type="int",
            )
        elif call.nodetype == NodeTypes.SOFT_KEYWORD:
            return FunctionCall(
                function=f"_PyPegen_lookahead_with_string",
                arguments=[positive, call.function, *call.arguments],
                return_type="int",
            )
        elif call.nodetype in {NodeTypes.GENERIC_TOKEN, NodeTypes.KEYWORD}:
            return FunctionCall(
                function=f"_PyPegen_lookahead_with_int",
                arguments=[positive, call.function, *call.arguments],
                return_type="int",
                comment=f"token={node.node}",
            )
        else:
            return FunctionCall(
                function=f"_PyPegen_lookahead",
                arguments=[positive, call.function, *call.arguments],
                return_type="int",
            )

    def visit_PositiveLookahead(self, node: PositiveLookahead) -> FunctionCall:
        return self.lookahead_call_helper(node, 1)

    def visit_NegativeLookahead(self, node: NegativeLookahead) -> FunctionCall:
        return self.lookahead_call_helper(node, 0)

    def visit_Opt(self, node: Opt) -> FunctionCall:
        print(self.create_indent(), "visit_Opt:", node)
        self.indent += 2
        call = self.generate_call(node.node)
        print(self.create_indent(), "call:", call)
        result = FunctionCall(
            assigned_variable="_opt_var",
            function=call.function,
            arguments=call.arguments,
            force_true=True,
            comment=f"{node}",
        )
        print(self.create_indent(), "result: ", result)
        self.indent -= 2
        return result

    def visit_Repeat0(self, node: Repeat0) -> FunctionCall:
        if node in self.cache:
            return self.cache[node]
        name = self.gen.name_loop(node.node, False)
        self.cache[node] = FunctionCall(
            assigned_variable=f"{name}_var",
            function=f"{name}_rule",
            arguments=["p"],
            return_type="asdl_seq *",
            comment=f"{node}",
        )
        return self.cache[node]

    def visit_Repeat1(self, node: Repeat1) -> FunctionCall:
        if node in self.cache:
            return self.cache[node]
        name = self.gen.name_loop(node.node, True)
        self.cache[node] = FunctionCall(
            assigned_variable=f"{name}_var",
            function=f"{name}_rule",
            arguments=["p"],
            return_type="asdl_seq *",
            comment=f"{node}",
        )
        return self.cache[node]

    def visit_Gather(self, node: Gather) -> FunctionCall:
        if node in self.cache:
            return self.cache[node]
        name = self.gen.name_gather(node)
        self.cache[node] = FunctionCall(
            assigned_variable=f"{name}_var",
            function=f"{name}_rule",
            arguments=["p"],
            return_type="asdl_seq *",
            comment=f"{node}",
        )
        return self.cache[node]

    def visit_Group(self, node: Group) -> FunctionCall:
        return self.generate_call(node.rhs)

    def visit_Cut(self, node: Cut) -> FunctionCall:
        return FunctionCall(
            assigned_variable="_cut_var",
            return_type="int",
            function="1",
            nodetype=NodeTypes.CUT_OPERATOR,
        )
    
    def generate_call(self, node: Any) -> FunctionCall:
        print(self.create_indent(), "generate call for", node)
        self.indent += 2
        #print(self.create_indent(), "super()", super())
        result = super().visit(node)
        print(self.create_indent(), "result: ", result)
        self.indent -= 2
        return result
    
    def create_indent(self):
        s = ""
        for i in range(self.indent):
            s = s + " "
        return s
            
JAVA_PREFIX = """
// @generated by pegen from {filename}
"""

class JavaParserGenerator(ParserGenerator, GrammarVisitor):
    def __init__(
        self,
        grammar: grammar.Grammar,
        tokens: Dict[int, str],
        exact_tokens: Dict[str, int],
        non_exact_tokens: Set[str],
        file: Optional[IO[Text]],
    ):
        super().__init__(grammar, tokens, file)
        self.callmakervisitor = JavaCallMakerVisitor(
            self, exact_tokens, non_exact_tokens
        )

    def generate(self, filename: str) -> None:
        print("JavaParserGenerator.generate")
        header = self.grammar.metas.get("header", JAVA_PREFIX)
        print(self.grammar.metas)
        print(header)
        if header is not None:
            self.print(header.rstrip("\n").format(filename=filename))
        subheader = self.grammar.metas.get("subheader", "")
        if subheader:
            self.print(subheader.format(filename=filename))
        self.collect_todo()
        self.print("class GeneratedParser {")
        with self.indent():
            self.print()
            self.print("private int mark;")
            self.print()
        while self.todo:
            for rulename, rule in list(self.todo.items()):
#                self.print('//', rulename)
                if rule.left_recursive:
                    self.print('// left-recursive')
                del self.todo[rulename]
#                with self.indent():
                self.visit(rule)
#        trailer = self.grammar.metas.get("trailer", MODULE_SUFFIX)
#        if trailer is not None:
#            self.print(trailer.rstrip("\n"))
        self.print("}")

    def add_return(self, ret_val: str) -> None:
#        self.remove_level()
        self.print(f"return {ret_val};")
        
    def _should_memoize(self, node: Rule) -> bool:
        return node.memo and not node.left_recursive
    
    def _handle_default_rule_body(self, node: Rule, rhs: Rhs, result_type: str) -> None:
        memoize = self._should_memoize(node)
        # TODO needs to be added leveles
        # TODO needs check for errors ?
        with self.indent():
            self.print(f"// node handle yet {memoize}")
            self.print(f"{result_type} _res = null;")
            
            # TODO memoize
            
            self.print("int _mark = this.mark;")
            if (any(alt.action and "EXTRA" in alt.action for alt in rhs.alts)):
                self.print("// TODO _set_up_token_start_metadata_extraction();")
            # TODO do we need to work with rulename? 
            # self.visit(rhs, is_loop=False, is_gather=node.is_gather(), rulename=node.name)
            self.visit(rhs, is_loop=False, is_gather=node.is_gather())
            self.add_return("_res")
            
            
    def _handle_loop_rule_body(self, node: Rule, rhs: Rhs) -> None:
        
        with self.indent():
            self.print(f"// loop - not handled yet")
            self.print(f"Object[] _res = null;")
            self.add_return("_res")
        
    def visit_Rule(self, node: Rule) -> None:
        is_loop = node.is_loop()
        is_gather = node.is_gather()
        rhs = node.flatten()
        
        if is_loop or is_gather:
            result_type = "Object []"
        elif node.type:
#            result_type = node.type
             result_type = "Object"
        else:
            result_type = "void"
        
        with self.indent():
            for line in str(node).splitlines():
                self.print(f"// {line}")
            self.print(f"{result_type} {node.name}_rule() {{")
            if result_type != "void":
                if is_loop :
                    self._handle_loop_rule_body(node, rhs)
                else:
                    self._handle_default_rule_body(node, rhs, result_type)
            self.print("}")
        self.print()
#        if node.left_recursive:
#            if node.leader:
#                self.print("@memoize_left_rec")
#            else:
#                # Non-leader rules in a cycle are not memoized,
#                # but they must still be logged.
#                self.print("@logger")
#        else:
#            self.print("@memoize")
#        node_type = node.type or "Any"
#        self.print(f"def {node.name}(self) -> Optional[{node_type}]:")
#        with self.indent():
#            self.print(f"# {node.name}: {rhs}")
#            if node.nullable:
#                self.print(f"# nullable={node.nullable}")
#            self.print("mark = self.mark()")
#            if is_loop:
#                self.print("children = []")
#            self.visit(rhs, is_loop=is_loop, is_gather=is_gather)
#            if is_loop:
#                self.print("return children")
#            else:
#                self.print("return None")

    def visit_NamedItem(self, node: NamedItem) -> None:
        self.print("//TODO process NamedItem")
#        name, call = self.callmakervisitor.visit(node.item)
#        if node.name:
#            name = node.name
#        if not name:
#            self.print(call)
#        else:
#            if name != "cut":
#                name = self.dedupe(name)
#            self.print(f"({name} := {call})")

    def visit_Rhs(self, node: Rhs, is_loop: bool = False, is_gather: bool = False) -> None:
        if is_loop:
            assert len(node.alts) == 1
        for alt in node.alts:
            self.visit(alt, is_loop=is_loop, is_gather=is_gather)

    def visit_Alt(self, node: Alt, is_loop: bool, is_gather: bool) -> None:
        self.print("//TODO process Alt")
        with self.indent():
            self.print("//TODO check for errors")
            # Prepare variable declarations for the alternative
            vars = self.collect_vars(node)
            for v, var_type in sorted(item for item in vars.items() if item[0] is not None):
                if not var_type:
                    var_type = "void "
                else:
                    var_type += " "
                if v == "_cut_var":
                    v += " = 0"  # cut_var must be initialized
                self.print(f"{var_type}{v};")
                #if v.startswith("_opt_var"):
                #    self.print(f"UNUSED({v}); // Silence compiler warnings")
            with self.local_variable_context():
                if is_loop:
                    self.print("//TODO self.handle_alt_loop(node, is_gather, rulename)")
                else:
                    self.print("//TODO self.handle_alt_normal(node, is_gather, rulename)")    
#        with self.local_variable_context():
#            self.print("cut = False")  # TODO: Only if needed.
#            if is_loop:
#                self.print("while (")
#            else:
#                self.print("if (")
#            with self.indent():
#                first = True
#                for item in node.items:
#                    if first:
#                        first = False
#                    else:
#                        self.print("and")
#                    self.visit(item)
#                    if is_gather:
#                        self.print("is not None")
#
#            self.print("):")
#            with self.indent():
#                action = node.action
#                if not action:
#                    if is_gather:
#                        assert len(self.local_variable_names) == 2
#                        action = (
#                            f"[{self.local_variable_names[0]}] + {self.local_variable_names[1]}"
#                        )
#                    else:
#                        action = f"[{', '.join(self.local_variable_names)}]"
#                if is_loop:
#                    self.print(f"children.append({action})")
#                    self.print(f"mark = self.mark()")
#                else:
#                    self.print(f"return {action}")
#            self.print("self.reset(mark)")
#            # Skip remaining alternatives if a cut was reached.
#            self.print("if cut: return None")  # TODO: Only if needed.

    def collect_vars(self, node: Alt) -> Dict[Optional[str], Optional[str]]:
        types = {}
        with self.local_variable_context():
            for item in node.items:
                name, type = self.add_var(item)
                types[name] = type
        return types
    
    def add_var(self, node: NamedItem) -> Tuple[Optional[str], Optional[str]]:
        print("###add_var")
        call = self.callmakervisitor.generate_call(node.item)
        print("add_var.call:", call)
        name = node.name if node.name else call.assigned_variable
        if name is not None:
            name = self.dedupe(name)
        print("add_var.call.return_type:", call.return_type)
        return_type = call.return_type if node.type is None else node.type
        
        return name, return_type